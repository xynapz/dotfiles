#!/usr/bin/env python3
import os
import sys
import argparse
import subprocess
import shutil
import json
import tarfile
import urllib.request
import urllib.error
import time
import signal
from pathlib import Path
from datetime import datetime

SCRIPT_VERSION = "2.0.0"
HELIUM_DIR = Path(os.environ.get("HELIUM_DIR", "/opt/helium"))
BINARY = HELIUM_DIR / "chrome"
PROFILES_DIR = Path(
    os.environ.get("HELIUM_PROFILES_DIR", Path.home() / ".config/helium-profiles")
)
LOG_FILE = Path(
    os.environ.get("HELIUM_LOG_FILE", Path.home() / ".local/share/helium/helium.log")
)
CACHE_DIR = Path.home() / ".cache/helium"
GITHUB_REPO = "imputnet/helium-linux"
GITHUB_API = f"https://api.github.com/repos/{GITHUB_REPO}/releases/latest"
LOCKFILE = Path("/tmp/helium-update.lock")
VERSION_FILE = HELIUM_DIR / "VERSION"


class Colors:
    RED = "\033[0;31m"
    GREEN = "\033[0;32m"
    YELLOW = "\033[1;33m"
    BLUE = "\033[0;34m"
    CYAN = "\033[0;36m"
    RESET = "\033[0m"


def log(level, message):
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    LOG_FILE.parent.mkdir(parents=True, exist_ok=True)
    with open(LOG_FILE, "a") as f:
        f.write(f"[{timestamp}] [{level}] {message}\n")


def print_error(message):
    print(f"{Colors.RED}✗ ERROR:{Colors.RESET} {message}", file=sys.stderr)
    log("ERROR", message)


def print_success(message):
    print(f"{Colors.GREEN}✓ SUCCESS:{Colors.RESET} {message}")
    log("INFO", message)


def print_warning(message):
    print(f"{Colors.YELLOW}⚠ WARNING:{Colors.RESET} {message}")
    log("WARN", message)


def print_info(message):
    print(f"{Colors.BLUE}ℹ INFO:{Colors.RESET} {message}")


def print_step(message):
    print(f"{Colors.CYAN}→{Colors.RESET} {message}")


def confirm(prompt):
    response = input(f"{prompt} (y/N): ").lower()
    return response == "y"


class HeliumManager:
    @staticmethod
    def validate_installation():
        if not HELIUM_DIR.exists():
            print_error(f"Helium not installed at {HELIUM_DIR}")
            print_info("Run: helium install")
            return False

        if not BINARY.exists():
            print_error(f"Helium binary not found at {BINARY}")
            return False

        if not os.access(BINARY, os.X_OK):
            print_warning("Binary not executable, attempting to fix...")
            try:
                BINARY.chmod(BINARY.stat().st_mode | 0o111)  # +x
                print_success("Binary permissions fixed")
            except Exception as e:
                print_error(f"Cannot make binary executable: {e}")
                return False
        return True

    @staticmethod
    def get_current_version():
        if VERSION_FILE.exists():
            return VERSION_FILE.read_text().strip()
        return "unknown"

    @staticmethod
    def get_latest_metadata():
        try:
            with urllib.request.urlopen(GITHUB_API, timeout=10) as response:
                return json.loads(response.read().decode())
        except Exception as e:
            print_error(f"Failed to fetch release info: {e}")
            return None

    @staticmethod
    def install():
        print_step("Starting Helium installation...")

        release_data = HeliumManager.get_latest_metadata()
        if not release_data:
            return

        version = release_data.get("tag_name")
        print_info(f"Latest version: {version}")

        # Find asset
        download_url = next(
            (
                asset["browser_download_url"]
                for asset in release_data.get("assets", [])
                if asset["name"].endswith("-x86_64_linux.tar.xz")
            ),
            None,
        )

        if not download_url:
            print_error("Could not find Linux x86_64 download")
            return

        tmp_file = Path(f"/tmp/helium-{version}.tar.xz")
        print_step(f"Downloading Helium {version}...")

        try:
            urllib.request.urlretrieve(download_url, tmp_file)
        except Exception as e:
            print_error(f"Download failed: {e}")
            return

        # Backup
        if HELIUM_DIR.exists():
            backup_dir = Path(
                f"/tmp/helium-backup-{datetime.now().strftime('%Y%m%d-%H%M%S')}"
            )
            print_step(f"Backing up current installation to {backup_dir}")
            try:
                shutil.move(str(HELIUM_DIR), str(backup_dir))
            except Exception as e:
                print_error(f"Backup failed: {e}")
                tmp_file.unlink()
                return

        # Extract
        print_step("Extracting archive...")
        try:
            HELIUM_DIR.mkdir(parents=True, exist_ok=True)
            with tarfile.open(tmp_file, "r:xz") as tar:
                members = []
                for member in tar.getmembers():
                    p = Path(member.name)
                    if len(p.parts) > 1:
                        member.name = str(Path(*p.parts[1:]))
                        members.append(member)
                tar.extractall(path=HELIUM_DIR, members=members)

        except Exception as e:
            print_error(f"Extraction failed: {e}")
            tmp_file.unlink()
            return

        try:
            if BINARY.exists():
                BINARY.chmod(BINARY.stat().st_mode | 0o111)
        except Exception as e:
            print_warning(f"Could not set permissions: {e}")

        VERSION_FILE.write_text(version)
        tmp_file.unlink()
        print_success(f"Helium {version} installed successfully")

    @staticmethod
    def check_stale_lock(profile_path):
        lock_file = profile_path / "SingletonLock"
        if not os.path.lexists(lock_file):
            return

        try:
            if lock_file.is_symlink():
                target = os.readlink(lock_file)
            else:
                return

            parts = target.split("-")
            if len(parts) < 2:
                return

            try:
                pid = int(parts[-1])
            except ValueError:
                return

            path = Path(f"/proc/{pid}")
            if not path.exists():
                print_warning(f"Found stale lock for PID {pid}. Cleaning up...")
                lock_file.unlink()
                (profile_path / "SingletonCookie").unlink(missing_ok=True)
                (profile_path / "SingletonSocket").unlink(missing_ok=True)
                print_success("Stale lock removed.")
        except Exception as e:
            print_warning(f"Failed to check/clean stale lock: {e}")

    @staticmethod
    def launch(args):
        if not HeliumManager.validate_installation():
            return

        profile_name = args.profile or os.environ.get("HELIUM_PROFILE", "default")

        if not all(c.isalnum() or c in "-_" for c in profile_name):
            print_error("Invalid profile name")
            return

        profile_path = PROFILES_DIR / profile_name

        if not profile_path.exists():
            print_error(f"Profile '{profile_name}' does not exist.")
            print_info(f"Create it first with: helium profile create {profile_name}")
            return

        HeliumManager.check_stale_lock(profile_path)

        cmd = [str(BINARY)]
        cmd.append(f"--user-data-dir={profile_path}")

        if args.incognito:
            cmd.append("--incognito")
        if args.verbose:
            cmd.extend(["--enable-logging", "--v=1"])
        if args.fullscreen:
            cmd.append("--start-fullscreen")
        if args.kiosk:
            cmd.append("--kiosk")
        if args.new_window:
            cmd.append("--new-window")
        if args.no_sandbox:
            cmd.append("--no-sandbox")
        if args.disable_gpu:
            cmd.append("--disable-gpu")
        if args.remote_debugging_port:
            cmd.append(f"--remote-debugging-port={args.remote_debugging_port}")

        cmd.extend(args.urls)

        print_info(
            f"Launching Helium with profile: {Colors.CYAN}{profile_name}{Colors.RESET}"
        )

        if args.verbose:
            print_info(f"Command: {cmd}")
            subprocess.Popen(cmd)
        else:
            subprocess.Popen(
                cmd,
                start_new_session=True,
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
            )
            print_success("Helium launched in background")

    @staticmethod
    def create_desktop_entry():
        if not HeliumManager.validate_installation():
            return

        desktop_dir = Path.home() / ".local/share/applications"
        desktop_file = desktop_dir / "helium-browser.desktop"
        icon_file = HELIUM_DIR / "product_logo_256.png"

        # Get absolute path of this script to use in Exec
        script_path = str(Path(__file__).resolve())

        print_step("Creating desktop entry...")
        desktop_dir.mkdir(parents=True, exist_ok=True)

        content = f"""[Desktop Entry]
Version=1.0
Name=Helium Browser
GenericName=Web Browser
Comment=Fast, secure Chromium-based browser
Exec={script_path} launch %U
Icon={icon_file}
Type=Application
Categories=Network;WebBrowser;
Keywords=browser;web;internet;
StartupNotify=true
StartupWMClass=helium-browser
Terminal=false
MimeType=text/html;text/xml;application/xhtml+xml;application/xml;application/rss+xml;application/rdf+xml;image/gif;image/jpeg;image/png;x-scheme-handler/http;x-scheme-handler/https;x-scheme-handler/ftp;x-scheme-handler/chrome;video/webm;application/x-xpinstall;
Actions=NewWindow;NewPrivateWindow;

[Desktop Action NewWindow]
Name=New Window
Exec={script_path} launch --new-window

[Desktop Action NewPrivateWindow]
Name=New Private Window
Exec={script_path} launch --incognito
"""
        try:
            desktop_file.write_text(content)
            desktop_file.chmod(0o755)

            # Update database if tool exists
            if shutil.which("update-desktop-database"):
                subprocess.run(
                    ["update-desktop-database", str(desktop_dir)],
                    stderr=subprocess.DEVNULL,
                )

            print_success(f"Desktop entry created at {desktop_file}")
        except Exception as e:
            print_error(f"Failed to create desktop entry: {e}")

    @staticmethod
    def setup():
        print_step("Setting up Helium Browser Manager...")

        # Create directories
        try:
            PROFILES_DIR.mkdir(parents=True, exist_ok=True)
            CACHE_DIR.mkdir(parents=True, exist_ok=True)
            LOG_FILE.parent.mkdir(parents=True, exist_ok=True)
            LOG_FILE.touch(exist_ok=True)

            # Create default profile
            (PROFILES_DIR / "default").mkdir(exist_ok=True)

            HeliumManager.create_desktop_entry()

            print_success("Setup complete")
            print_info(
                f"Configuration saved to:\n  Profiles: {PROFILES_DIR}\n  Log file: {LOG_FILE}"
            )

        except Exception as e:
            print_error(f"Setup failed: {e}")

    @staticmethod
    def kill():
        print_step("Terminating Helium instances...")
        try:
            if PROFILES_DIR.exists():
                for p in PROFILES_DIR.iterdir():
                    if p.is_dir():
                        lock = p / "SingletonLock"
                        if os.path.lexists(lock) and lock.is_symlink():
                            try:
                                target = os.readlink(lock)
                                pid_str = target.split("-")[-1]
                                pid = int(pid_str)
                                os.kill(pid, signal.SIGTERM)
                                print_info(f"Sent SIGTERM to {pid} (Profile: {p.name})")
                            except (ValueError, ProcessLookupError):
                                pass
                            except Exception as e:
                                print_warning(f"Error killing {p.name}: {e}")

            time.sleep(1)

            subprocess.run(
                ["pkill", "-f", str(BINARY)],
                check=False,
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
            )
            print_success("All Helium instances terminated.")
        except Exception as e:
            print_error(f"Failed to kill processes: {e}")


class ProfileManager:
    @staticmethod
    def list_profiles():
        if not PROFILES_DIR.exists() or not any(PROFILES_DIR.iterdir()):
            print_info("No profiles found")
            return

        print_info("Available profiles:\n")
        for p in PROFILES_DIR.iterdir():
            if p.is_dir():
                size = sum(f.stat().st_size for f in p.rglob("*") if f.is_file()) / (
                    1024 * 1024
                )
                print(f"  {Colors.CYAN}{p.name:<20}{Colors.RESET} {size:.1f}MB")
        print("")

    @staticmethod
    def create(name):
        path = PROFILES_DIR / name
        if path.exists():
            print_warning(f"Profile '{name}' already exists")
            return
        path.mkdir(parents=True)
        print_success(f"Profile '{name}' created")

    @staticmethod
    def delete(name):
        if name == "default":
            print_error("Cannot delete default profile")
            return
        path = PROFILES_DIR / name
        if not path.exists():
            print_error(f"Profile '{name}' not found")
            return

        if confirm(f"Delete profile '{name}'?"):
            shutil.rmtree(path)
            print_success(f"Profile '{name}' deleted")


def main():
    known_commands = {
        "install",
        "update",
        "setup",
        "kill",
        "launch",
        "profile",
        "clear-cache",
        "info",
        "version",
        "help",
    }

    if len(sys.argv) > 1:
        first_arg = sys.argv[1]

        if not first_arg.startswith("-") and first_arg not in known_commands:
            if "://" not in first_arg:
                new_args = [sys.argv[0], "launch", "--profile", first_arg]
                new_args.extend(sys.argv[2:])
                sys.argv = new_args

    parser = argparse.ArgumentParser(description="Helium Browser Manager")
    subparsers = parser.add_subparsers(dest="command")

    # Launch
    cmd_launch = subparsers.add_parser("launch", help="Launch browser")
    cmd_launch.add_argument("urls", nargs="*", help="URLs to open")
    cmd_launch.add_argument("-p", "--profile", help="Profile to use")
    cmd_launch.add_argument("-i", "--incognito", action="store_true")
    cmd_launch.add_argument("-f", "--fullscreen", action="store_true")
    cmd_launch.add_argument("-k", "--kiosk", action="store_true")
    cmd_launch.add_argument("-n", "--new-window", action="store_true")
    cmd_launch.add_argument("-v", "--verbose", action="store_true")
    cmd_launch.add_argument("--no-sandbox", action="store_true")
    cmd_launch.add_argument("--disable-gpu", action="store_true")
    cmd_launch.add_argument("--remote-debugging-port", type=int)

    # Install
    subparsers.add_parser("install", help="Install Helium")
    subparsers.add_parser("update", help="Update Helium")
    subparsers.add_parser("setup", help="Initialize desktop integration")
    subparsers.add_parser("kill", help="Kill all instances")

    # Profile
    cmd_profile = subparsers.add_parser("profile", help="Manage profiles")
    profile_subs = cmd_profile.add_subparsers(dest="profile_action")

    p_create = profile_subs.add_parser("create")
    p_create.add_argument("name")

    p_delete = profile_subs.add_parser("delete")
    p_delete.add_argument("name")

    profile_subs.add_parser("list")

    args = parser.parse_args()

    if args.command == "launch" or not args.command:
        if not args.command:
            args.profile = None
            args.incognito = False
            args.urls = []

        if args.command is None:
            args.profile = None
            args.incognito = False
            args.fullscreen = False
            args.kiosk = False
            args.new_window = False
            args.verbose = False
            args.no_sandbox = False
            args.disable_gpu = False
            args.remote_debugging_port = None
            args.urls = []

        HeliumManager.launch(args)

    elif args.command == "install":
        HeliumManager.install()
    elif args.command == "update":
        HeliumManager.install()
    elif args.command == "setup":
        HeliumManager.setup()
    elif args.command == "kill":
        HeliumManager.kill()
    elif args.command == "profile":
        if args.profile_action == "list" or not args.profile_action:
            ProfileManager.list_profiles()
        elif args.profile_action == "create":
            ProfileManager.create(args.name)
        elif args.profile_action == "delete":
            ProfileManager.delete(args.name)


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\nAborted.")
        sys.exit(130)
