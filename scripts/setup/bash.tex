% Created 2025-12-05 Fri 03:34
% Intended LaTeX compiler: xelatex
\documentclass[11pt]{article}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{capt-of}
\usepackage{hyperref}
\usepackage[margin=1in]{geometry}
\usepackage{fontspec}
\usepackage{xunicode}
\usepackage{ulem}
\usepackage{listings}
\usepackage{color}
\date{\today}
\title{XZ SYSTEM SETUP SCRIPT}
\hypersetup{
 pdfauthor={},
 pdftitle={XZ SYSTEM SETUP SCRIPT},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 30.2 (Org mode 9.7.11)}, 
 pdflang={English}}
\begin{document}

\maketitle
\tableofcontents

\section{Learning Bash}
\label{sec:org64c887c}
I am writing this post from arch post installation environment, where I dont have any desktop environment setup, I am
documenting this process of writing a bash script to automate my post-install steps of my arch-linux system.
\subsection{About Bash}
\label{sec:org5db969f}
Bash is a scripting language or a command interpreter developed for unix-like systems like linux. It was created by
Brian Fox in 1989, and named It \textbf{Bash (Bourne Again Shell)} indicating its a born anew shell scripting language that
was meant to replace its predecessor, Bourne Shell AKA \textbf{sh}
\subsection{My History and Usecases}
\label{sec:org825d456}
I knew of the concept of automating batch of repetitive tasks using scripting in linux environments from way back from
my college days, where I would often distro-hop, try new tools, naively participate in linux community formus in sites
like reddits, arch-wiki, ubuntu-stackexchage, etc. I know a very basic level of scripting right now as well, but I
would not say that I am a master at it to solve any freakin problem with scripting. But I have used linux for almost
7 years, 8 in May 2026, and just knowing the basics in 7 years is shameful, This post will first, test my skill boundary
in bash and rework on it and learn new things my writing a script to setup the post-arch installation, desktop environment
for myself, using my already existing \href{https://github.com/xynapz/dotfiles}{dotfiles repository} in github.
\subsection{Deep Dive Into The Topics}
\label{sec:org615bac4}

\subsubsection{Bash Invocation \& Startup}
\label{sec:org5d8be19}

Invocation is just another name for how bash starts up, think of it like how a computer system start (normal mode, safe mode,
recovery mode), bash also does a similar thing to boot itself up, during when a user login to system or starts a shell
in already authenticated environment. This is the invocation of bash.

Startup files are the initial script files that the bash executes when it starts.
\begin{enumerate}
\item Two methods of invocation
\label{sec:orge8db161}

\begin{enumerate}
\item Interactive \& Non-Interactive Invocations
\label{sec:orgf417f8f}
\textbf{Interactive}: This is the way which most users of linux are very familiar way of running some bash commands. When you open a terminal,
it waits for you to type a command in, after a symbol, mostly after \textbf{\$} symbol, it then executes the command and returns
the output to the terminal. This method of invocation handles history of commands, and the process/job/task itself.

\textbf{Non-Interactive}: A non-interact invocation is the method of bash invocation in which, a script file is run instead of
a command. All scripts use non-interactive shell for invocation and they cannot do any other task in between execution
of that script.
\item Login \& Non-Login Interactive Invocation
\label{sec:orgbbd7130}

\textbf{Login Shell}: This is the shell, a user gets access to after authenticating with their username and password during
the session start. This is the stage where bash sets up the entire environment, including PATH and other environment
variables.

\textbf{Non-Login Shell}: After you are logged in to your desktop, you open a new terminal, or open a new tab inside of an
already opened terminal, or when typing bash inside of an existing shell, the shell that starts is the non-login shell.
\end{enumerate}
\item Scenario 1: Invocation with Interactive Login Shell.
\label{sec:org98baa6f}
When we first login to a system, the bash shell reads some startup scripts in order, they are as follows:
\begin{enumerate}
\item \textbf{/etc/profile} which contains system-wide environment variables and configurations.
\item Then it looks for one of these files in order:
\begin{itemize}
\item \textasciitilde{}/.bash\_profile
\item \textasciitilde{}/.bash\_login
\item \textasciitilde{}/.profile
\end{itemize}
\item And upon logout \textbf{\textasciitilde{}/.bash\_logout} is read.
\end{enumerate}

\textbf{Now a question arised in my mind}
\textbf{how about the .bashrc file?}
Well it seems \textbf{.bashrc} file is not read by the login shell. This file is read by the non-login shells, explained below
in \hyperref[sec:org3d01790]{Scenario 2}.
\item Scenario 2: Invocation with Interactive Non-Login Shell.
\label{sec:org3d01790}
When we open a terminal by clicking on the terminal icon from our desktop, the shell that opens is a interactive non-login
shell. Or, if we open a new tab in already opened terminal, or.These are few examples of interactive non-login shell.

The files the bash shell reads when entering the interactive non-login shell is, intense music, more-intensified music,
yes, its \textbf{\textasciitilde{}/.bashrc}
\item Scenario 3: Invoking in Non-Interactive Shell.
\label{sec:org459e0ec}
All script files that run are in a non-interactive shell. In this scenario, the script is run in a clean slate, to make
sure that the script runs predictably.
\item Scenario 4: Invocation with the sh command.
\label{sec:org51f05f1}
If you create a symbolic link of bash and name it as sh, and run a script using thew new named sh link, it runs as a
POSIX standard \textbf{sh} shelll instead.
In that case it will read these files in order:
\begin{enumerate}
\item /etc/profile
\item \textasciitilde{}/.bash\_profile
\end{enumerate}
\item Scenario 5: Invocation in POSIX Mode.
\label{sec:org374edcc}
In this mode, bash is forced to adhere to the POSIX standard to execute the scripts. We can enable posix mode by running
\textbf{set -o posix} or running bash with \textbf{--posix} option, will also force the standard, the last approach is, by setting the
environment variable \textbf{POSIXLY\_CORRECT}, which also forces the POSIX standard for the script we are trying to run. The
advantage of this is that our script will be able to run in most system that adhere to strict POSIX standard.
\item Scenatio 6: Invoked Remotely.
\label{sec:org909c630}
When we invoke a script in a remote shell, the file read by the remote shell is the \textbf{\textasciitilde{}/.bashrc} file.
\end{enumerate}
\subsubsection{Logging}
\label{sec:org058e407}
While writing a shell script, in my opinion, it is very important to see real-time log of what commands are executing?,
what procedure are being executed?, what issue has arrised? these details are very crucial for observing, analysing
and debugging the script in case if the script fails or crashes. Using colorful text appropriately is a best practice
that will make it easier to read info from a black screen.

To log data from a script to a standard output like a terminal screen, we can just do echo to print stuff on the screen.
\begin{lstlisting}[language=bash,numbers=none]
echo "Message to log to the screen."
\end{lstlisting}
\subsubsection{Immediate Termination Upon Error}
\label{sec:org1a30dce}
In most cases, when we are using a script to automate a task, we want the script to terminate its execution immediately
if there is any sort of issue, bug, or any kind of bad signal received. The reason for this immediate exit on error is,
a script is a series of instruction, that have to executed in order, and there is point in executing the next instruction
if an error has occured while executing the current instruction.
\subsubsection{Variables}
\label{sec:org8b52cdf}
As any other programming language, a bash is just a named identifier for a data object. There are two types of variables
in bash, \textbf{global} variables and \textbf{local} variables.
\begin{enumerate}
\item Global Variable
\label{sec:orgfbfd7f9}
A global variable is a variable that is available in all the shells in a system. It is also called environment variables.
They are named \textbf{ALL\_CAPS} to denote they are global or environment variables. They can be set in shell configuration files
which makes it available to all available shells. In a shell, we can view all global variables using \textbf{env} or \textbf{printenv}
commands.

\begin{lstlisting}[language=bash,numbers=none]
env
\end{lstlisting}
\item Local Variables
\label{sec:orgd2c9c24}
Local Variables are variables that are available in the current shell only. In some conventions local variables
are all capitalized and in some conventions they are not. So its up to the user to follow a style for naming
their own local variables, but being consistent here is the key.
\item Types of Variables
\label{sec:org0a6e0cd}
The variables in bash has four main types, they are:
\begin{itemize}
\item Integer Variables
\item String Variables
\item Constant Variables
\item Array Variables
\end{itemize}
\item Creating Variables
\label{sec:orgd7a988b}
Variables in bash are case-sensitive, naming a variable is simple in bash, you can give any name, but giving a variable
a name that starts with a digit is an error.

\begin{lstlisting}[language=bash,numbers=none]
1name="Angel"
echo "$1name"
\end{lstlisting}
\begin{enumerate}
\item Space around equals (=) sign
\label{sec:org431b7dd}
Giving a space around equal sign will result in an error. Example
\begin{lstlisting}[language=bash,numbers=none]
name = "Angel"
echo "$name"
\end{lstlisting}

\begin{lstlisting}[language=bash,numbers=none]
name="Angel"
echo "$name"
\end{lstlisting}

Above in the the first example, if you look closely, there is space around \textbf{=} while assigning \textbf{Angel} to name, this is
not allowed while creating a variable in bash, the second code block which doesn't have any leading or trailing space
around \textbf{=} sign, is valid syntax to create a variable in bash.
\item Exporting a Variable
\label{sec:org3d9cb3f}
A variable that we create is only available in that shell, if we want a variable to exists for all of its child-shell also
called subshells, child-process, etc. then we can export a variable using the \textbf{export} keyword, what that does, is, it
basically exports that variables for all of its child-process to access it, even modify it, but the modified variables
only exists within that child-shell or its children shells, but not in the parent shell, it still has its original reference.

\begin{lstlisting}[language=bash,numbers=none]
export name='Angel'
\end{lstlisting}

In above example, the name variable will be available to the child shell that this command is run on.
\end{enumerate}
\item Reserved Keywords
\label{sec:org3219532}
Since bash is a extension of sh, all the reserved keywords of sh are also reserved in bash, plus there are a few more
reserved keywords that bash has, so naming our variables, that is not a reserved keyword is a compulsory. Some examples
are, \textbf{HOME}, \textbf{PATH}, \textbf{PS1}, \textbf{SHELL}, etc.
\end{enumerate}
\subsubsection{Quoting, Expansion and Aliases}
\label{sec:orgd459bdc}
\begin{enumerate}
\item Quoting Characters
\label{sec:orga53f176}
In bash a lot of characters have special meaning to them, syntactly and logically. Quoting is a mechanism of removing
those sepcial meaning of those characters and lay them as plain ASCII characters.
\begin{enumerate}
\item Escape Character
\label{sec:org6743cd1}
Escape character is used to remove the special meaning from a single character. To acheive this a non-quoted backslash,
\textbf{$\backslash$}, is used as the escape character in bash.

\begin{lstlisting}[language=bash,numbers=none]
#without escape char
name="Angel"
echo "$name"

#with escape char
echo "\$name"
\end{lstlisting}
\item Single Quotes
\label{sec:orgaa70328}
Everything withing the single quotes is taken literally, this is also called strong quoting. Every special characters
inside the single quote loses its meaning these include \textbf{\$}, \textbf{$\backslash$}, \textbf{$\backslash$"} etc. A single quote character \textbf{'} also cannot
be inside single quotes.

One example:
\begin{lstlisting}[language=bash,numbers=none]
echo '$date'
\end{lstlisting}
\item Double Quotes
\label{sec:orga5693eb}
Double quoting a variable or text is known as weak quoting. It quotes the literal value of all characters except,
backslash \textbf{$\backslash$}, dollar sign \textbf{\$} and backticks \textbf{``}.

\begin{lstlisting}[language=bash,numbers=none]
echo "Angel'$\"\\"
\end{lstlisting}
\end{enumerate}
\item Shell Expansion
\label{sec:orgd9afc71}
When bash executes a script, it splits the commands into tokens (operands, operators, etc), some of these tokens might
not be resolved, one famous example is \textbf{\textasciitilde{}} symbol, it doesnt have any meaning in the linux-kernel, its the bash shell
that resolves \textbf{\textasciitilde{}} to \textbf{\emph{home/uname}} everywhere it encounters the symbol. And there are eight types of symbol exansion
in bash.

\textbf{\textbf{Brace Expansion}}
\textbf{\textbf{Tilde Expansion}}
\textbf{\textbf{Parameter \& Variable Expansion}}
\textbf{\textbf{Command Substitution}}
\textbf{\textbf{Arithmetic Expansion}}
\textbf{\textbf{Process Substitution}}
\textbf{\textbf{Word Splitting}}
\textbf{\textbf{Filename Expansion}}
\textbf{\textbf{Aliases}}

You can get more information about them at \href{https://tldp.org/LDP/Bash-Beginners-Guide/html/Basic-Beginner-Guide.html\#sect\_03\_04}{TLDP-Bash-Beginners-Guide}.
\end{enumerate}
\subsubsection{Regular Expressions}
\label{sec:org5372d95}
Regular expression is a topic that should have a post dedicated for it. Which I have added in the bucket list, but the
main crux here is, most of the text manipulation in bash is done using regular-expressions, Their usecase in text-processing
is so wide that, I will write a article about it definitely in the near future.
\subsubsection{The GNU sed stream editor}
\label{sec:orgf00f509}
\emph{coming soon}
\subsubsection{The GNU awk programming language}
\label{sec:orgdbd38a1}
\emph{coming soon}
\subsubsection{Conditional Statements}
\label{sec:orgf9a7730}
\emph{coming soon}
\subsubsection{Looping and Repetition}
\label{sec:org12fd292}
\emph{coming soon}
\subsubsection{Functions}
\label{sec:orgf00d6e0}
In bash, functions exists, like other programming languages, they are used for reusing repetitive piece of logic multiple
times without repeating too much. Function usually takes arguments executes some instructions or commands in bash and
return back. The syntax for a function is simple, the name of the function followd by a pair of parenthesis, and the
function's body enclosed inside a pair of curly braces.

\begin{lstlisting}[language=bash,numbers=none]
log () {
    echo "Static Message"
}

log_file() {
    echo "$1"
}

log
log_file "test.sh"
\end{lstlisting}
\subsubsection{Little about signals}
\label{sec:org52a79bb}
\end{document}
